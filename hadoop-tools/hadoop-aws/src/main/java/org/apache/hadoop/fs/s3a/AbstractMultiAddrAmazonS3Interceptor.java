/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.fs.s3a;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashSet;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.util.ReflectionUtils;
import com.amazonaws.regions.Region;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.S3ClientOptions;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

/**
 *
 * New implementation of S3Client is generated by cglib
 *
 * */
public abstract class AbstractMultiAddrAmazonS3Interceptor
  implements MethodInterceptor {
  private S3ClientSelector selector;
  private final HashSet<MethodProperties> scanAllClientMethods
    = new HashSet<MethodProperties>(),
      emptyMethodExceptionMethods = new HashSet<MethodProperties>();
  private final MethodProperties setEndPointMethod;
  private void addMethod(HashSet<MethodProperties> set, String methodName,
      Class<?>...paramTypes) throws NoSuchMethodException,
      SecurityException {
    set.add(new MethodProperties(
        AmazonS3.class.getMethod(methodName, paramTypes)));
  }

  public AbstractMultiAddrAmazonS3Interceptor(Configuration conf) {
    Class<? extends S3ClientSelector> selectorClass =
        conf.getClass("fs.s3a.S3ClientSelector.class",
      RandomS3ClientSelector.class, S3ClientSelector.class);
    selector = ReflectionUtils.newInstance(selectorClass, conf);
    try {
      setEndPointMethod = new MethodProperties(
          AmazonS3.class.getMethod("setEndpoint", String.class));
      addMethod(scanAllClientMethods, "setS3ClientOptions",
          S3ClientOptions.class);
      addMethod(scanAllClientMethods, "shutdown");
      addMethod(emptyMethodExceptionMethods, "setRegion", Region.class);
      addMethod(emptyMethodExceptionMethods, "getRegion");
      addMethod(emptyMethodExceptionMethods, "getRegionName");
      addMethod(emptyMethodExceptionMethods, "createBucket",
          String.class,com.amazonaws.services.s3.model.Region.class);
      } catch (NoSuchMethodException | SecurityException e) {
          throw new RuntimeException("Exception caused by code error", e);
      }
    }

  @Override
  public Object intercept(Object obj, Method method, Object[] params,
      MethodProxy proxy) throws Throwable {
    if(!(obj instanceof AmazonS3)) {
      throw new IllegalArgumentException("obj must be subclass of "
          + AmazonS3.class.getName());
    }
    MethodProperties mp = new MethodProperties(method);

    //setEndpoint method handle
    if(mp.equals(setEndPointMethod)){
      doSetEndPoint((String)params[0]);
      return null;
    }

    //Operation which apply all clients
    if(void.class.equals(method.getReturnType())
        && scanAllClientMethods.contains(mp)){
      for(AmazonS3 s3:selector.s3ClientList()){
        proxy.invoke(s3, params);
      }
      return null;
    }

    //Unsupported operation handle
    if(emptyMethodExceptionMethods.contains(mp)){
      throw new UnsupportedOperationException(
          String.format("Method %s not supported.", method));
    }

    //Select one s3 client by selector and execute.
    AmazonS3 selectedS3 = selector.getCurrS3ByMethod(method, params);
    return proxy.invoke(selectedS3, params);
  }

  //Implementation of setEndpoint method.
  private void doSetEndPoint(String endpoint) {
    String[] endPointArr = endpoint.split(",");
    if(endPointArr.length == 0){
      throw new IllegalArgumentException("endpoint cannot be null!");
    }
    AmazonS3[] tmp = new AmazonS3[endPointArr.length];
    for(int i = 0;i < tmp.length;i++){
      tmp[i] = doCreateNewClient();
      tmp[i].setEndpoint(endPointArr[i]);
    }
    selector.setS3Arr(tmp);
  }

  protected abstract AmazonS3 doCreateNewClient();

  private static class MethodProperties{
    private int modifiers;
    private boolean isSubClassOfAmazonS3;
    private String name;
    private Class<?> paramTypes[];
    private Class<?> returnType;
    MethodProperties(Method method) {
      modifiers = method.getModifiers();
      isSubClassOfAmazonS3 = AmazonS3.class.isAssignableFrom(
          method.getDeclaringClass());
      name = method.getName();
      paramTypes = method.getParameterTypes();
      returnType = method.getReturnType();
    }
    @Override
    public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + (isSubClassOfAmazonS3 ? 1231 : 1237);
      result = prime * result + modifiers;
      result = prime * result + ((name == null) ? 0 : name.hashCode());
      result = prime * result + Arrays.hashCode(paramTypes);
      result = prime * result + ((returnType == null) ? 0 : returnType.hashCode());
      return result;
    }
    @Override
    public boolean equals(Object obj) {
      if (this == obj){
        return true;
      }
      if (obj == null) {
        return false;
      }
      if (getClass() != obj.getClass()){
        return false;
      }
      MethodProperties other = (MethodProperties) obj;
      if (isSubClassOfAmazonS3 != other.isSubClassOfAmazonS3){
        return false;
      }
      if (modifiers != other.modifiers){
        return false;
      }
      if (name == null) {
        if (other.name != null) {
          return false;
        }
      } else if (!name.equals(other.name)){
        return false;
      }
      if (!Arrays.equals(paramTypes, other.paramTypes)){
        return false;
      }
      if (returnType == null) {
        if (other.returnType != null){
          return false;
        }
      } else if (!returnType.equals(other.returnType)){
        return false;
      }
      return true;
    }
    @Override
    public String toString() {
      return "MethodProperties [name=" + name +
          ", paramTypes=" + Arrays.toString(paramTypes) +
          " ,returnType=" + returnType + "]";
    }

  }
}